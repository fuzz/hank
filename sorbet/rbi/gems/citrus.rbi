# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/citrus/all/citrus.rbi
#
# citrus-3.0.2

module Citrus
  def self.cache; end
  def self.eval(code, options = nil); end
  def self.load(file, options = nil); end
  def self.require(file, options = nil); end
  def self.rule(expr, options = nil); end
  def self.version; end
end
class Citrus::Error < StandardError
end
class Citrus::LoadError < Citrus::Error
end
class Citrus::ParseError < Citrus::Error
  def detail; end
  def initialize(input); end
  def line; end
  def line_number; end
  def line_offset; end
  def offset; end
end
class Citrus::SyntaxError < Citrus::Error
  def initialize(error); end
end
class Citrus::Input < StringScanner
  def apply_rule(rule, position, events); end
  def exec(rule, events = nil); end
  def initialize(source); end
  def line(pos = nil); end
  def line_index(pos = nil); end
  def line_number(pos = nil); end
  def line_offset(pos = nil); end
  def lineno(pos = nil); end
  def lines; end
  def max_offset; end
  def memoized?; end
  def reset; end
  def source; end
  def source_text(source); end
  def test(rule); end
  def to_str; end
end
class Citrus::MemoizedInput < Citrus::Input
  def apply_rule(rule, position, events); end
  def cache; end
  def cache_hits; end
  def initialize(string); end
  def memoized?; end
  def reset; end
end
module Citrus::Grammar
  def self.included(mod); end
  def self.new(&block); end
end
module Citrus::GrammarMethods
  def all(*args, &block); end
  def andp(rule, &block); end
  def any(*args, &block); end
  def butp(rule, &block); end
  def dot(&block); end
  def ext(rule, mod = nil, &block); end
  def has_rule?(name); end
  def included_grammars; end
  def label(rule, label, &block); end
  def mod(rule, &block); end
  def name; end
  def notp(rule, &block); end
  def one_or_more(rule, &block); end
  def parse(source, options = nil); end
  def parse_file(path, options = nil); end
  def rep(rule, min = nil, max = nil, &block); end
  def root(name = nil); end
  def rule(name, obj = nil, &block); end
  def rule_names; end
  def rules; end
  def self.extend_object(obj); end
  def setup_super(rule, name); end
  def sup(&block); end
  def super_rule(name); end
  def zero_or_more(rule, &block); end
  def zero_or_one(rule, &block); end
end
module Citrus::Rule
  def ==(other); end
  def ===(obj); end
  def default_options; end
  def elide?; end
  def eql?(other); end
  def extend_match(match); end
  def extension; end
  def extension=(mod); end
  def grammar; end
  def grammar=(arg0); end
  def inspect; end
  def label; end
  def label=(label); end
  def name; end
  def name=(name); end
  def needs_paren?; end
  def parse(source, options = nil); end
  def self.for(obj); end
  def terminal?; end
  def test(string, options = nil); end
  def to_embedded_s; end
  def to_s; end
  def to_str; end
end
module Citrus::Proxy
  def elide?; end
  def exec(input, events = nil); end
  def extend_match(match); end
  def initialize(rule_name = nil); end
  def rule; end
  def rule_name; end
  def rule_name=(rule_name); end
  include Citrus::Rule
end
class Citrus::Alias
  def resolve!; end
  def to_citrus; end
  include Citrus::Proxy
end
class Citrus::Super
  def resolve!; end
  def to_citrus; end
  include Citrus::Proxy
end
class Citrus::Terminal
  def ==(other); end
  def case_sensitive?; end
  def eql?(other); end
  def exec(input, events = nil); end
  def initialize(regexp = nil); end
  def regexp; end
  def terminal?; end
  def to_citrus; end
  include Citrus::Rule
end
class Citrus::StringTerminal < Citrus::Terminal
  def ==(other); end
  def eql?(other); end
  def initialize(rule = nil, flags = nil); end
  def to_citrus; end
end
module Citrus::Nonterminal
  def grammar=(grammar); end
  def initialize(rules = nil); end
  def rules; end
  include Citrus::Rule
end
class Citrus::AndPredicate
  def exec(input, events = nil); end
  def initialize(rule = nil); end
  def rule; end
  def to_citrus; end
  include Citrus::Nonterminal
end
class Citrus::NotPredicate
  def exec(input, events = nil); end
  def initialize(rule = nil); end
  def rule; end
  def to_citrus; end
  include Citrus::Nonterminal
end
class Citrus::ButPredicate
  def exec(input, events = nil); end
  def initialize(rule = nil); end
  def rule; end
  def to_citrus; end
  include Citrus::Nonterminal
end
class Citrus::Repeat
  def exec(input, events = nil); end
  def initialize(rule = nil, min = nil, max = nil); end
  def max; end
  def min; end
  def operator; end
  def rule; end
  def to_citrus; end
  include Citrus::Nonterminal
end
class Citrus::Sequence
  def exec(input, events = nil); end
  def to_citrus; end
  include Citrus::Nonterminal
end
class Citrus::Choice
  def elide?; end
  def exec(input, events = nil); end
  def to_citrus; end
  include Citrus::Nonterminal
end
class Citrus::Match
  def ==(other); end
  def [](key, *args); end
  def capture!(rule, match); end
  def capture(name); end
  def captures(name = nil); end
  def captures_hash; end
  def dump(indent = nil); end
  def eql?(other); end
  def events; end
  def first; end
  def initialize(input, events = nil, offset = nil); end
  def input; end
  def inspect; end
  def length; end
  def matches; end
  def offset; end
  def process_events!; end
  def source; end
  def string; end
  def to_a; end
  def to_s; end
  def to_str; end
  def value; end
end
module Citrus::ModuleNameHelpers
  def module_basename; end
  def module_name; end
  def module_namespace; end
  def module_segments; end
end
module Citrus::File
  def self.parse(*); end
  extend Citrus::GrammarMethods
  include Citrus::Grammar
end
